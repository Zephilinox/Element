# Matrix definitions
#
# The default constructors for Matrices use row Vectors,
# and there are also a "fromCols" function to allow definition
# using column vectors. A corresponding "fromRows" function
# also exists which can be used to help with code readability.

struct Matrix2x2(xRow:Vector2, yRow:Vector2)
{
    # Factories
    identity:Matrix2x2 = Matrix2x2.fromDiagonal(Vector2.one)

    fromRows(xRow:Vector2, yRow:Vector2):Matrix2x2
    {
        return = Matrix2x2(xRow, yRow)
    }

    fromCols(xCol:Vector2, yCol:Vector2):Matrix2x2
    {
        return = Matrix2x2(xCol, yCol).transpose
    }

    fromDiagonal(diag:Vector2):Matrix2x2
    {
        # Create a diagonal matrix from the specified vector
        return = Matrix2x2(Vector2(diag.x, 0), Vector2(0, diag.y))
    }

    # Properties

    xCol(m:Matrix2x2):Vector2 = Vector2(m.xRow.x, m.yRow.x)
    yCol(m:Matrix2x2):Vector2 = Vector2(m.xRow.y, m.yRow.y)

    diagonal(m:Matrix2x2):Vector2 = Vector2(m.xRow.x, m.yRow.y)

    transpose(m:Matrix2x2):Matrix2x2 = Matrix2x2(m.xCol, m.yCol)

    determinant(m:Matrix2x2):Num
    {
        return = m.xCol.x.mul(m.yCol.y).sub(m.xCol.y.mul(m.yCol.x))
    }

    # Operations
    mul(a:Matrix2x2, b:Matrix2x2):Matrix2x2
    {
        m_00 = a.xRow.dot(b.xCol)
        m_01 = a.xRow.dot(b.yCol)
        m_10 = a.yRow.dot(b.xCol)
        m_11 = a.yRow.dot(b.yCol)
        mxRow = Vector2(m_00, m_01)
        myRow = Vector2(m_10, m_11)
        return = Matrix2x2.fromRows(mxRow, myRow)
    }

    mulVec(m:Matrix2x2, v:Vector2):Vector2
    {
        return = Vector2(m.xRow.dot(v), m.yRow.dot(v))
    }
}


struct Matrix3x3(xRow:Vector3, yRow:Vector3, zRow:Vector3)
{
    # Factories
    identity:Matrix3x3 = Matrix3x3.fromDiagonal(Vector3.one)

    fromCols(xCol:Vector3, yCol:Vector3, zCol:Vector3):Matrix3x3
    {
        return = Matrix3x3(xCol, yCol, zCol).transpose
    }

    fromRows(xRow:Vector3, yRow:Vector3, zRow:Vector3):Matrix3x3
    {
        return = Matrix3x3(xRow, yRow, zRow)
    }

    fromDiagonal(diag:Vector3):Matrix3x3
    {
        # Create a diagonal matrix from the specified vector
        return = Matrix3x3(Vector3(diag.x, 0, 0), Vector3(0, diag.y, 0), Vector3(0, 0, diag.z))
    }

    # Properties
    xCol(m:Matrix3x3) = Vector3(m.xRow.x, m.yRow.x, m.zRow.x)
    yCol(m:Matrix3x3) = Vector3(m.xRow.y, m.yRow.y, m.zRow.y)
    zCol(m:Matrix3x3) = Vector3(m.xRow.z, m.yRow.z, m.zRow.z)

    diagonal(m:Matrix3x3) = Vector3(m.xRow.x, m.yRow.y, m.zRow.z)

    transpose(m:Matrix3x3):Matrix3x3 = Matrix3x3(m.xCol, m.yCol, m.zCol)

    determinant(m:Matrix3x3):Num
    {
        signVector:Vector3 = Vector3(1, -1, 1)
        topRow:Vector3 = m.xRow

        xSubCol:Vector2 = Vector2(m.xCol.y, m.xCol.z)
        ySubCol:Vector2 = Vector2(m.yCol.y, m.yCol.z)
        zSubCol:Vector2 = Vector2(m.zCol.y, m.zCol.z)

        subDeterminants:Vector3 = Vector3(
            Matrix2x2.fromCols(ySubCol, zSubCol).determinant,
            Matrix2x2.fromCols(xSubCol, zSubCol).determinant,
            Matrix2x2.fromCols(xSubCol, ySubCol).determinant
        )
        resultComponents:Vector3 = Vector3(
            topRow.x.mul(subDeterminants.x),
            topRow.y.mul(subDeterminants.y),
            topRow.z.mul(subDeterminants.z)
        )

        return = resultComponents.dot(signVector)
    }

    # Operations
    mul(a:Matrix3x3, b:Matrix3x3):Matrix3x3
    {
        createNewRow = _(v:Vector3, m:Matrix3x3)
        {
            return = Vector3(v.dot(m.xCol), v.dot(m.yCol), v.dot(m.zCol))
        }

        multipliedMatrix = Matrix3x3(
            createNewRow(a.xRow, b),
            createNewRow(a.yRow, b),
            createNewRow(a.zRow, b)
        )

        return = multipliedMatrix
    }

    mulVec(m:Matrix3x3, v:Vector3):Vector3
    {
        return = Vector3(m.xRow.dot(v), m.yRow.dot(v), m.zRow.dot(v))
    }
}


struct Matrix4x4(xRow:Vector4, yRow:Vector4, zRow:Vector4, wRow:Vector4)
{
    identity = Matrix4x4.fromDiagonal(Vector4.one)

    fromRows(xRow:Vector4, yRow:Vector4, zRow:Vector4, wRow:Vector4):Matrix4x4
    {
        return = Matrix4x4(xRow, yRow, zRow, wRow)
    }

    fromCols(xCol:Vector4, yCol:Vector4, zCol:Vector4, wCol:Vector4):Matrix4x4
    {
        return = Matrix4x4(xCol, yCol, zCol, wCol).transpose
    }

    xCol(m:Matrix4x4) = Vector4(m.xRow.x, m.yRow.x, m.zRow.x, m.wRow.x)
    yCol(m:Matrix4x4) = Vector4(m.xRow.y, m.yRow.y, m.zRow.y, m.wRow.y)
    zCol(m:Matrix4x4) = Vector4(m.xRow.z, m.yRow.z, m.zRow.z, m.wRow.z)
    wCol(m:Matrix4x4) = Vector4(m.xRow.w, m.yRow.w, m.zRow.w, m.wRow.w)

    transpose(m:Matrix4x4):Matrix4x4 = Matrix4x4(m.xCol, m.yCol, m.zCol, m.wCol)

    mul(a:Matrix4x4, b:Matrix4x4):Matrix4x4
    {
        x_component = Vector4(a.xRow.dot(b.x), a.yRow.dot(b.x), a.zRow.dot(b.x), a.wRow.dot(b.w))
        y_component = Vector4(a.xRow.dot(b.y), a.yRow.dot(b.y), a.zRow.dot(b.y), a.wRow.dot(b.w))
        z_component = Vector4(a.xRow.dot(b.z), a.yRow.dot(b.z), a.zRow.dot(b.z), a.wRow.dot(b.w))
        w_component = Vector4(a.xRow.dot(b.w), a.yRow.dot(b.w), a.zRow.dot(b.w), a.wRow.dot(b.w))
    
        return = Matrix4x4(x_component, y_component, z_component, w_component)
    }

    mulVec(this:Matrix4x4, column_vector:Vector4):Vector4
    {
        multiply(matrixRow_vector:Vector4):Num = matrixRow_vector.dot(column_vector)
        x = multiply(this.xRow)
        y = multiply(this.yRow)
        z = multiply(this.zRow)
        w = multiply(this.wRow)
        return = Vector4(x, y, z, w)
    }

    mulNum(a:Matrix4x4, b:Num):Matrix4x4
    {
        x_component = a.x.mul(b)
        y_component = a.y.mul(b)
        z_component = a.z.mul(b)
        w_component = a.w.mul(b)
    
        return = Matrix4x4(x_component, y_component, z_component, w_component)
    }
    
    add(a:Matrix4x4, b:Matrix4x4):Matrix4x4
    {
        return = Matrix4x4(
            Vector4(a.x.add(b.x)),
            Vector4(a.y.add(b.y)),
            Vector4(a.z.add(b.z)),
            Vector4(a.w.add(b.w)))
    }
}